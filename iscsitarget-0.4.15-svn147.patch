Index: kernel/block-io.c
===================================================================
--- kernel/block-io.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/block-io.c	(.../trunk)	(revision 147)
@@ -28,15 +28,10 @@
 	struct completion tio_complete;
 };
 
-static int
-blockio_bio_endio(struct bio *bio, unsigned int bytes_done, int error)
+static void blockio_bio_endio(struct bio *bio, int error)
 {
 	struct tio_work *tio_work = bio->bi_private;
 
-	/* Ignore partials */
-	if (bio->bi_size)
-		return 1;
-
 	error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? error : -EIO;
 
 	if (error)
@@ -47,8 +42,6 @@
 		complete(&tio_work->tio_complete);
 
 	bio_put(bio);
-
-	return 0;
 }
 
 /*
@@ -169,8 +162,8 @@
 
 	bdev = open_bdev_excl(path, flags, THIS_MODULE);
 	if (IS_ERR(bdev)) {
-		err = PTR_ERR (bdev);
-		eprintk("Can't open device %s \n", path);
+		err = PTR_ERR(bdev);
+		eprintk("Can't open device %s, error %d\n", path, err);
 		bio_data->bdev = NULL;
 	} else {
 		bio_data->bdev = bdev;
@@ -217,7 +210,7 @@
 	p = (u32 *) (volume->scsi_id + VENDOR_ID_LEN);
 	*(p + 0) = volume->target->trgt_param.target_type;
 	*(p + 1) = volume->target->tid;
-	*(p + 2) = (unsigned int) inode->i_ino;
+	*(p + 2) = volume->lun;
 	*(p + 3) = (unsigned int) inode->i_sb->s_dev;
 }
 
@@ -319,6 +312,7 @@
 
 	if (bio_data->bdev)
 		close_bdev_excl(bio_data->bdev);
+	kfree(bio_data->path);
 
 	kfree(volume->private);
 }
Index: kernel/target_disk.c
===================================================================
--- kernel/target_disk.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/target_disk.c	(.../trunk)	(revision 147)
@@ -66,13 +66,15 @@
 	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
 				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	u32 ncyl, *p;
+	u32 ncyl;
+	u32 n;
 
 	/* assume 0xff heads, 15krpm. */
 	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
 	ncyl = sec >> 14; /* 256 * 64 */
-	p = (u32 *)(ptr + 1);
-	*p = *p | cpu_to_be32(ncyl);
+	memcpy(&n, ptr+1, sizeof(u32));
+	n = n | cpu_to_be32(ncyl);
+	memcpy(ptr+1, &n, sizeof(u32));
 	return sizeof(geo_m_pg);
 }
 
@@ -249,7 +251,8 @@
 	struct iet_volume *lun;
 	int rest, idx = 0;
 
-	size = be32_to_cpu(*(u32 *)&req->scb[6]);
+	size = (u32)req->scb[6] << 24 | (u32)req->scb[7] << 16 |
+		(u32)req->scb[8] << 8 | (u32)req->scb[9];
 	if (size < 16)
 		return -1;
 
Index: kernel/config.c
===================================================================
--- kernel/config.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/config.c	(.../trunk)	(revision 147)
@@ -40,7 +40,7 @@
 	int i;
 	struct proc_dir_entry *ent;
 
-	if (!(proc_iet_dir = proc_mkdir("net/iet", 0)))
+	if (!(proc_iet_dir = proc_mkdir("iet", init_net.proc_net)))
 		goto err;
 
 	proc_iet_dir->owner = THIS_MODULE;
Index: kernel/volume.c
===================================================================
--- kernel/volume.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/volume.c	(.../trunk)	(revision 147)
@@ -132,6 +132,8 @@
 	list_add_tail(&volume->list, &target->volumes);
 	atomic_inc(&target->nr_volumes);
 
+	kfree(args);
+
 	return 0;
 free_args:
 	kfree(args);
Index: kernel/iotype.c
===================================================================
--- kernel/iotype.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/iotype.c	(.../trunk)	(revision 147)
@@ -89,9 +89,11 @@
 
 	for (i = 0; i < ARRAY_SIZE(iotype_array); i++) {
 		if (!(err = register_iotype(iotype_array[i])))
-			eprintk("register %s\n", iotype_array[i]->name);
+			iprintk("Registered io type %s\n",
+						iotype_array[i]->name);
 		else {
-			eprintk("failed to register %s\n", iotype_array[i]->name);
+			eprintk("Failed to register io type %s\n",
+						iotype_array[i]->name);
 			break;
 		}
 	}
Index: kernel/iscsi.c
===================================================================
--- kernel/iscsi.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/iscsi.c	(.../trunk)	(revision 147)
@@ -726,13 +726,18 @@
 	case READ_10:
 	case WRITE_10:
 	case WRITE_VERIFY:
-		*off = be32_to_cpu(*(u32 *)&cmd[2]);
+		*off = (u32)cmd[2] << 24 | (u32)cmd[3] << 16 |
+			(u32)cmd[4] << 8 | (u32)cmd[5];
 		*len = (cmd[7] << 8) + cmd[8];
 		break;
 	case READ_16:
 	case WRITE_16:
-		*off = be64_to_cpu(*(u64 *)&cmd[2]);
-		*len = be32_to_cpu(*(u32 *)&cmd[10]);
+		*off = (u64)cmd[2] << 56 | (u64)cmd[3] << 48 |
+			(u64)cmd[4] << 40 | (u64)cmd[5] << 32 |
+			(u64)cmd[6] << 24 | (u64)cmd[7] << 16 |
+			(u64)cmd[8] << 8 | (u64)cmd[9];
+		*len = (u32)cmd[10] << 24 | (u32)cmd[11] << 16 |
+			(u32)cmd[12] << 8 | (u32)cmd[13];
 		break;
 	default:
 		BUG();
@@ -1191,10 +1196,56 @@
 	}
 }
 
+static inline char *tmf_desc(int fun)
+{
+	static char *tmf_desc[] = {
+		"Unknown Function",
+		"Abort Task",
+		"Abort Task Set",
+		"Clear ACA",
+		"Clear Task Set",
+		"Logical Unit Reset",
+		"Target Warm Reset",
+		"Target Cold Reset",
+		"Task Reassign",
+        };
+
+	if ((fun < ISCSI_FUNCTION_ABORT_TASK) || 
+				(fun > ISCSI_FUNCTION_TASK_REASSIGN))
+		fun = 0;
+
+	return tmf_desc[fun];
+}
+
+static inline char *rsp_desc(int rsp)
+{
+	static char *rsp_desc[] = {
+		"Function Complete",
+		"Unknown Task",
+		"Unknown LUN",
+		"Task Allegiant",
+		"Failover Unsupported",
+		"Function Unsupported",
+		"No Authorization",
+		"Function Rejected",
+		"Unknown Response",
+	};
+
+	if (((rsp < ISCSI_RESPONSE_FUNCTION_COMPLETE) ||
+			(rsp > ISCSI_RESPONSE_NO_AUTHORIZATION)) &&
+			(rsp != ISCSI_RESPONSE_FUNCTION_REJECTED))
+		rsp = 8;
+	else if (rsp == ISCSI_RESPONSE_FUNCTION_REJECTED)
+		rsp = 7;
+
+	return rsp_desc[rsp];
+}
+
 static void execute_task_management(struct iscsi_cmnd *req)
 {
 	struct iscsi_conn *conn = req->conn;
-	struct iscsi_target *target = conn->session->target;
+	struct iscsi_session *session = conn->session;
+	struct iscsi_target *target = session->target;
 	struct iscsi_cmnd *rsp;
 	struct iscsi_task_mgt_hdr *req_hdr = (struct iscsi_task_mgt_hdr *)&req->pdu.bhs;
 	struct iscsi_task_rsp_hdr *rsp_hdr;
@@ -1209,8 +1260,6 @@
 	rsp_hdr->itt = req_hdr->itt;
 	rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_COMPLETE;
 
-	eprintk("%x %d %x\n", cmnd_itt(req), function, req_hdr->rtt);
-
 	switch (function) {
 	case ISCSI_FUNCTION_ABORT_TASK:
 	case ISCSI_FUNCTION_ABORT_TASK_SET:
@@ -1255,6 +1304,11 @@
 		break;
 	}
 out:
+	iprintk("%s (%02x) issued on tid:%d lun:%d by sid:%llu (%s)\n",
+				tmf_desc(function), function, target->tid,
+				translate_lun(req_hdr->lun), session->sid,
+				rsp_desc(rsp_hdr->response));
+
 	iscsi_cmnd_init_write(rsp);
 }
 
@@ -1708,8 +1762,7 @@
 	if ((err = event_init()) < 0)
 		goto err;
 
-	iscsi_cmnd_cache = kmem_cache_create("iscsi_cmnd", sizeof(struct iscsi_cmnd),
-					     0, 0, NULL, NULL);
+	iscsi_cmnd_cache = KMEM_CACHE(iscsi_cmnd, 0);
 	if (!iscsi_cmnd_cache)
 		goto err;
 
Index: kernel/null-io.c
===================================================================
--- kernel/null-io.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/null-io.c	(.../trunk)	(revision 147)
@@ -16,7 +16,7 @@
 #include "iotype.h"
 
 struct nullio_data {
-	u32 sectors;
+	u64 sectors;
 };
 
 enum {
@@ -32,7 +32,7 @@
 static int parse_nullio_params(struct iet_volume *volume, char *params)
 {
 	int err = 0;
-	char *p;
+	char *p, *q;
 	struct nullio_data *data = volume->private;
 
 	while ((p = strsep(&params, ",")) != NULL) {
@@ -43,7 +43,11 @@
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_sectors:
-			match_int(&args[0], &data->sectors);
+			q = match_strdup(&args[0]);
+			if (!q)
+				return -ENOMEM;
+			data->sectors = simple_strtoull(q, NULL, 10);
+			kfree(q);
 			break;
 		case Opt_ignore:
 			break;
@@ -97,7 +101,7 @@
 void nullio_show(struct iet_volume *lu, struct seq_file *seq)
 {
 	struct nullio_data *p = lu->private;
-	seq_printf(seq, " sectors:%u\n", p->sectors);
+	seq_printf(seq, " sectors:%llu\n", p->sectors);
 }
 
 struct iotype nullio =
Index: kernel/iscsi.h
===================================================================
--- kernel/iscsi.h	(.../tags/0.4.15)	(revision 147)
+++ kernel/iscsi.h	(.../trunk)	(revision 147)
@@ -116,9 +116,6 @@
 	struct worker_thread_info wthread_info;
 
 	struct semaphore target_sem;
-
-	struct list_head initiator_list;
-	u32 initiator_iid_count;
 };
 
 struct iscsi_queue {
@@ -189,8 +186,6 @@
 	struct list_head cmnd_hash[1 << IET_HASH_ORDER];
 
 	u32 next_ttt;
-
-	struct iscsi_initiator *rinitiator;
 };
 
 enum connection_state_bit {
Index: kernel/digest.c
===================================================================
--- kernel/digest.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/digest.c	(.../trunk)	(revision 147)
@@ -161,22 +161,17 @@
 	}
 }
 
-/* Copied from linux-iscsi initiator and slightly adjusted */
-#define SETSG(sg, p, l) do {					\
-	(sg).page = virt_to_page((p));				\
-	(sg).offset = ((unsigned long)(p) & ~PAGE_CACHE_MASK);	\
-	(sg).length = (l);					\
-} while (0)
-
 static void digest_header(struct hash_desc *hash, struct iscsi_pdu *pdu,
 			  u8 *crc)
 {
 	struct scatterlist sg[2];
 	unsigned int nbytes = sizeof(struct iscsi_hdr);
 
-	SETSG(sg[0], &pdu->bhs, nbytes);
+	sg_init_table(sg, pdu->ahssize ? 2 : 1);
+
+	sg_set_buf(&sg[0], &pdu->bhs, nbytes);
 	if (pdu->ahssize) {
-		SETSG(sg[1], pdu->ahs, pdu->ahssize);
+		sg_set_buf(&sg[1], pdu->ahs, pdu->ahssize);
 		nbytes += pdu->ahssize;
 	}
 
@@ -218,8 +213,9 @@
 	count = get_pgcnt(size, offset);
 	assert(idx + count <= tio->pg_cnt);
 
-	assert(count < ISCSI_CONN_IOV_MAX);
+	assert(count <= ISCSI_CONN_IOV_MAX);
 
+	sg_init_table(sg, ARRAY_SIZE(cmnd->conn->hash_sg));
 	crypto_hash_init(hash);
 
 	for (i = 0; size; i++) {
@@ -228,13 +224,13 @@
 		else
 			length = size;
 
-		sg[i].page = tio->pvec[idx + i];
-		sg[i].offset = offset;
-		sg[i].length = length;
+		sg_set_page(&sg[i], tio->pvec[idx + i], length, offset);
 		size -= length;
 		offset = 0;
 	}
 
+	sg_mark_end(&sg[i - 1]);
+
 	crypto_hash_update(hash, sg, nbytes);
 	crypto_hash_final(hash, crc);
 }
Index: kernel/event.c
===================================================================
--- kernel/event.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/event.c	(.../trunk)	(revision 147)
@@ -28,7 +28,7 @@
 	return 0;
 }
 
-static int event_recv_skb(struct sk_buff *skb)
+static void event_recv_skb(struct sk_buff *skb)
 {
 	int err;
 	struct nlmsghdr	*nlh;
@@ -37,7 +37,7 @@
 	while (skb->len >= NLMSG_SPACE(0)) {
 		nlh = (struct nlmsghdr *)skb->data;
 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
+			break;
 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
 		if (rlen > skb->len)
 			rlen = skb->len;
@@ -47,21 +47,8 @@
 			netlink_ack(skb, nlh, 0);
 		skb_pull(skb, rlen);
 	}
-	return 0;
 }
 
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
 static int notify(void *data, int len, int gfp_mask)
 {
 	struct sk_buff *skb;
@@ -95,7 +82,8 @@
 
 int event_init(void)
 {
-	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, THIS_MODULE);
+	nl = netlink_kernel_create(&init_net, NETLINK_IET, 1, event_recv_skb,
+				   NULL, THIS_MODULE);
 	if (!nl)
 		return -ENOMEM;
 	else
Index: kernel/nthread.c
===================================================================
--- kernel/nthread.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/nthread.c	(.../trunk)	(revision 147)
@@ -13,8 +13,6 @@
 #include "iscsi_dbg.h"
 #include "digest.h"
 
-DECLARE_WAIT_QUEUE_HEAD(iscsi_ctl_wait);
-
 enum daemon_state_bit {
 	D_ACTIVE,
 	D_DATA_READY,
Index: kernel/target.c
===================================================================
--- kernel/target.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/target.c	(.../trunk)	(revision 147)
@@ -148,7 +148,6 @@
 
 	INIT_LIST_HEAD(&target->session_list);
 	INIT_LIST_HEAD(&target->volumes);
-	INIT_LIST_HEAD(&target->initiator_list);
 
 	atomic_set(&target->nr_volumes, 0);
 
Index: kernel/iscsi_dbg.h
===================================================================
--- kernel/iscsi_dbg.h	(.../tags/0.4.15)	(revision 147)
+++ kernel/iscsi_dbg.h	(.../trunk)	(revision 147)
@@ -15,21 +15,25 @@
 
 extern unsigned long debug_enable_flags;
 
-#define dprintk(debug, fmt, args...)					\
-do {									\
-	if ((debug) & debug_enable_flags) {				\
-		printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-	}								\
+#define PFX "iscsi_trgt: "
+
+#define dprintk(debug, fmt, args...) do {			\
+	if ((debug) & debug_enable_flags) {			\
+		printk(KERN_DEBUG PFX "%s(%d) " fmt, __FUNCTION__,\
+						__LINE__, args);\
+	}							\
 } while (0)
 
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+#define eprintk(fmt, args...) do {				\
+	printk(KERN_ERR PFX "%s(%d) " fmt, __FUNCTION__,	\
+						__LINE__, args);\
 } while (0)
 
+#define iprintk(X...) printk(KERN_INFO PFX X)
+
 #define assert(p) do {						\
 	if (!(p)) {						\
-		printk(KERN_CRIT "BUG at %s:%d assert(%s)\n",	\
+		printk(KERN_CRIT PFX "BUG at %s:%d assert(%s)\n",\
 		       __FILE__, __LINE__, #p);			\
 		dump_stack();					\
 		BUG();						\
@@ -40,9 +44,10 @@
 static inline void iscsi_dump_iov(struct msghdr *msg)
 {
 	int i;
-	printk("%p, %d\n", msg->msg_iov, msg->msg_iovlen);
+	printk(PFX "%p, %d\n", msg->msg_iov, msg->msg_iovlen);
 	for (i = 0; i < min_t(size_t, msg->msg_iovlen, ISCSI_CONN_IOV_MAX); i++)
-		printk("%d: %p,%d\n", i, msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
+		printk(PFX "%d: %p,%d\n", i, msg->msg_iov[i].iov_base,
+						msg->msg_iov[i].iov_len);
 }
 #else
 #define iscsi_dump_iov(x) do {} while (0)
@@ -84,18 +89,18 @@
 	int i;
 
 	buf = (void *)&pdu->bhs;
-	printk("BHS: (%p,%d)\n", buf, sizeof(pdu->bhs));
+	printk(PFX "BHS: (%p,%d)\n", buf, sizeof(pdu->bhs));
 	for (i = 0; i < sizeof(pdu->bhs); i++)
 		iscsi_dump_char(*buf++);
 	iscsi_dump_char(-1);
 
 	buf = (void *)pdu->ahs;
-	printk("AHS: (%p,%d)\n", buf, pdu->ahssize);
+	printk(PFX "AHS: (%p,%d)\n", buf, pdu->ahssize);
 	for (i = 0; i < pdu->ahssize; i++)
 		iscsi_dump_char(*buf++);
 	iscsi_dump_char(-1);
 
-	printk("Data: (%d)\n", pdu->datasize);
+	printk(PFX "Data: (%d)\n", pdu->datasize);
 }
 
 #else
Index: kernel/tio.c
===================================================================
--- kernel/tio.c	(.../tags/0.4.15)	(revision 147)
+++ kernel/tio.c	(.../trunk)	(revision 147)
@@ -110,8 +110,7 @@
 
 int tio_init(void)
 {
-	tio_cache = kmem_cache_create("tio", sizeof(struct tio),
-				      0, 0, NULL, NULL);
+	tio_cache = KMEM_CACHE(tio, 0);
 	return  tio_cache ? 0 : -ENOMEM;
 }
 
Index: patches/compat-2.6.19-2.6.21.patch
===================================================================
--- patches/compat-2.6.19-2.6.21.patch	(.../tags/0.4.15)	(revision 0)
+++ patches/compat-2.6.19-2.6.21.patch	(.../trunk)	(revision 147)
@@ -0,0 +1,41 @@
+Index: kernel/event.c
+===================================================================
+--- kernel/event.c	(working copy)
++++ kernel/event.c	(revision 122)
+@@ -95,8 +95,7 @@ int event_send(u32 tid, u64 sid, u32 cid
+ 
+ int event_init(void)
+ {
+-	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, NULL,
+-				   THIS_MODULE);
++	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, THIS_MODULE);
+ 	if (!nl)
+ 		return -ENOMEM;
+ 	else
+Index: kernel/iscsi.c
+===================================================================
+--- kernel/iscsi.c	(working copy)
++++ kernel/iscsi.c	(revision 137)
+@@ -1757,7 +1757,8 @@ static int iscsi_init(void)
+ 	if ((err = event_init()) < 0)
+ 		goto err;
+ 
+-	iscsi_cmnd_cache = KMEM_CACHE(iscsi_cmnd, 0);
++	iscsi_cmnd_cache = kmem_cache_create("iscsi_cmnd", sizeof(struct iscsi_cmnd),
++					     0, 0, NULL, NULL);
+ 	if (!iscsi_cmnd_cache)
+ 		goto err;
+ 
+Index: kernel/tio.c
+===================================================================
+--- kernel/tio.c	(working copy)
++++ kernel/tio.c	(revision 137)
+@@ -110,7 +110,8 @@ int tio_sync(struct iet_volume *lu, stru
+ 
+ int tio_init(void)
+ {
+-	tio_cache = KMEM_CACHE(tio, 0);
++	tio_cache = kmem_cache_create("tio", sizeof(struct tio),
++				      0, 0, NULL, NULL);
+ 	return  tio_cache ? 0 : -ENOMEM;
+ }
Index: patches/compat-2.6.14-2.6.18.patch
===================================================================
--- patches/compat-2.6.14-2.6.18.patch	(.../tags/0.4.15)	(revision 147)
+++ patches/compat-2.6.14-2.6.18.patch	(.../trunk)	(revision 147)
@@ -2,7 +2,7 @@
 ===================================================================
 --- kernel/iscsi.h	(revision 105)
 +++ kernel/iscsi.h	(working copy)
-@@ -238,8 +238,8 @@ struct iscsi_conn {
+@@ -233,8 +233,8 @@ struct iscsi_conn {
  	u32 write_offset;
  	int write_state;
  
@@ -134,7 +134,7 @@
  	idx = offset >> PAGE_CACHE_SHIFT;
 @@ -220,7 +211,7 @@ static void digest_data(struct hash_desc
  
- 	assert(count < ISCSI_CONN_IOV_MAX);
+ 	assert(count <= ISCSI_CONN_IOV_MAX);
  
 -	crypto_hash_init(hash);
 +	crypto_digest_init(tfm);
Index: patches/compat-2.6.22-2.6.23.patch
===================================================================
--- patches/compat-2.6.22-2.6.23.patch	(.../tags/0.4.15)	(revision 0)
+++ patches/compat-2.6.22-2.6.23.patch	(.../trunk)	(revision 147)
@@ -0,0 +1,592 @@
+Index: kernel/block-io.c
+===================================================================
+--- kernel/block-io.c	(working copy)
++++ kernel/block-io.c	(revision 145)
+@@ -28,10 +28,15 @@ struct tio_work {
+ 	struct completion tio_complete;
+ };
+ 
+-static void blockio_bio_endio(struct bio *bio, int error)
++static int
++blockio_bio_endio(struct bio *bio, unsigned int bytes_done, int error)
+ {
+ 	struct tio_work *tio_work = bio->bi_private;
+ 
++	/* Ignore partials */
++	if (bio->bi_size)
++		return 1;
++
+ 	error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? error : -EIO;
+ 
+ 	if (error)
+@@ -42,6 +47,8 @@ static void blockio_bio_endio(struct bio
+ 		complete(&tio_work->tio_complete);
+ 
+ 	bio_put(bio);
++
++	return 0;
+ }
+ 
+ /*
+Index: kernel/config.c
+===================================================================
+--- kernel/config.c	(working copy)
++++ kernel/config.c	(revision 145)
+@@ -40,7 +40,7 @@ int iet_procfs_init(void)
+ 	int i;
+ 	struct proc_dir_entry *ent;
+ 
+-	if (!(proc_iet_dir = proc_mkdir("iet", init_net.proc_net)))
++	if (!(proc_iet_dir = proc_mkdir("net/iet", 0)))
+ 		goto err;
+ 
+ 	proc_iet_dir->owner = THIS_MODULE;
+Index: kernel/digest.c
+===================================================================
+--- kernel/digest.c	(working copy)
++++ kernel/digest.c	(revision 145)
+@@ -161,17 +161,22 @@ static inline void __dbg_simulate_data_d
+ 	}
+ }
+ 
++/* Copied from linux-iscsi initiator and slightly adjusted */
++#define SETSG(sg, p, l) do {					\
++	(sg).page = virt_to_page((p));				\
++	(sg).offset = ((unsigned long)(p) & ~PAGE_CACHE_MASK);	\
++	(sg).length = (l);					\
++} while (0)
++
+ static void digest_header(struct hash_desc *hash, struct iscsi_pdu *pdu,
+ 			  u8 *crc)
+ {
+ 	struct scatterlist sg[2];
+ 	unsigned int nbytes = sizeof(struct iscsi_hdr);
+ 
+-	sg_init_table(sg, pdu->ahssize ? 2 : 1);
+-
+-	sg_set_buf(&sg[0], &pdu->bhs, nbytes);
++	SETSG(sg[0], &pdu->bhs, nbytes);
+ 	if (pdu->ahssize) {
+-		sg_set_buf(&sg[1], pdu->ahs, pdu->ahssize);
++		SETSG(sg[1], pdu->ahs, pdu->ahssize);
+ 		nbytes += pdu->ahssize;
+ 	}
+ 
+@@ -215,7 +220,6 @@ static void digest_data(struct hash_desc
+ 
+ 	assert(count <= ISCSI_CONN_IOV_MAX);
+ 
+-	sg_init_table(sg, ARRAY_SIZE(cmnd->conn->hash_sg));
+ 	crypto_hash_init(hash);
+ 
+ 	for (i = 0; size; i++) {
+@@ -224,13 +228,13 @@ static void digest_data(struct hash_desc
+ 		else
+ 			length = size;
+ 
+-		sg_set_page(&sg[i], tio->pvec[idx + i], length, offset);
++		sg[i].page = tio->pvec[idx + i];
++		sg[i].offset = offset;
++		sg[i].length = length;
+ 		size -= length;
+ 		offset = 0;
+ 	}
+ 
+-	sg_mark_end(&sg[i - 1]);
+-
+ 	crypto_hash_update(hash, sg, nbytes);
+ 	crypto_hash_final(hash, crc);
+ }
+Index: kernel/event.c
+===================================================================
+--- kernel/event.c	(working copy)
++++ kernel/event.c	(revision 145)
+@@ -28,7 +28,7 @@ static int event_recv_msg(struct sk_buff
+ 	return 0;
+ }
+ 
+-static void event_recv_skb(struct sk_buff *skb)
++static int event_recv_skb(struct sk_buff *skb)
+ {
+ 	int err;
+ 	struct nlmsghdr	*nlh;
+@@ -37,7 +37,7 @@ static void event_recv_skb(struct sk_buf
+ 	while (skb->len >= NLMSG_SPACE(0)) {
+ 		nlh = (struct nlmsghdr *)skb->data;
+ 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+-			break;
++			return 0;
+ 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+ 		if (rlen > skb->len)
+ 			rlen = skb->len;
+@@ -47,6 +47,19 @@ static void event_recv_skb(struct sk_buf
+ 			netlink_ack(skb, nlh, 0);
+ 		skb_pull(skb, rlen);
+ 	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
+ }
+ 
+ static int notify(void *data, int len, int gfp_mask)
+@@ -82,8 +95,8 @@ int event_send(u32 tid, u64 sid, u32 cid
+ 
+ int event_init(void)
+ {
+-	nl = netlink_kernel_create(&init_net, NETLINK_IET, 1, event_recv_skb,
+-				   NULL, THIS_MODULE);
++	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, NULL,
++				   THIS_MODULE);
+ 	if (!nl)
+ 		return -ENOMEM;
+ 	else
+Index: kernel/block-io.c
+===================================================================
+--- kernel/block-io.c	(working copy)
++++ kernel/block-io.c	(revision 145)
+@@ -28,10 +28,15 @@ struct tio_work {
+ 	struct completion tio_complete;
+ };
+ 
+-static void blockio_bio_endio(struct bio *bio, int error)
++static int
++blockio_bio_endio(struct bio *bio, unsigned int bytes_done, int error)
+ {
+ 	struct tio_work *tio_work = bio->bi_private;
+ 
++	/* Ignore partials */
++	if (bio->bi_size)
++		return 1;
++
+ 	error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? error : -EIO;
+ 
+ 	if (error)
+@@ -42,6 +47,8 @@ static void blockio_bio_endio(struct bio
+ 		complete(&tio_work->tio_complete);
+ 
+ 	bio_put(bio);
++
++	return 0;
+ }
+ 
+ /*
+Index: kernel/config.c
+===================================================================
+--- kernel/config.c	(working copy)
++++ kernel/config.c	(revision 145)
+@@ -40,7 +40,7 @@ int iet_procfs_init(void)
+ 	int i;
+ 	struct proc_dir_entry *ent;
+ 
+-	if (!(proc_iet_dir = proc_mkdir("iet", init_net.proc_net)))
++	if (!(proc_iet_dir = proc_mkdir("net/iet", 0)))
+ 		goto err;
+ 
+ 	proc_iet_dir->owner = THIS_MODULE;
+Index: kernel/digest.c
+===================================================================
+--- kernel/digest.c	(working copy)
++++ kernel/digest.c	(revision 145)
+@@ -161,17 +161,22 @@ static inline void __dbg_simulate_data_d
+ 	}
+ }
+ 
++/* Copied from linux-iscsi initiator and slightly adjusted */
++#define SETSG(sg, p, l) do {					\
++	(sg).page = virt_to_page((p));				\
++	(sg).offset = ((unsigned long)(p) & ~PAGE_CACHE_MASK);	\
++	(sg).length = (l);					\
++} while (0)
++
+ static void digest_header(struct hash_desc *hash, struct iscsi_pdu *pdu,
+ 			  u8 *crc)
+ {
+ 	struct scatterlist sg[2];
+ 	unsigned int nbytes = sizeof(struct iscsi_hdr);
+ 
+-	sg_init_table(sg, pdu->ahssize ? 2 : 1);
+-
+-	sg_set_buf(&sg[0], &pdu->bhs, nbytes);
++	SETSG(sg[0], &pdu->bhs, nbytes);
+ 	if (pdu->ahssize) {
+-		sg_set_buf(&sg[1], pdu->ahs, pdu->ahssize);
++		SETSG(sg[1], pdu->ahs, pdu->ahssize);
+ 		nbytes += pdu->ahssize;
+ 	}
+ 
+@@ -215,7 +220,6 @@ static void digest_data(struct hash_desc
+ 
+ 	assert(count <= ISCSI_CONN_IOV_MAX);
+ 
+-	sg_init_table(sg, ARRAY_SIZE(cmnd->conn->hash_sg));
+ 	crypto_hash_init(hash);
+ 
+ 	for (i = 0; size; i++) {
+@@ -224,13 +228,13 @@ static void digest_data(struct hash_desc
+ 		else
+ 			length = size;
+ 
+-		sg_set_page(&sg[i], tio->pvec[idx + i], length, offset);
++		sg[i].page = tio->pvec[idx + i];
++		sg[i].offset = offset;
++		sg[i].length = length;
+ 		size -= length;
+ 		offset = 0;
+ 	}
+ 
+-	sg_mark_end(&sg[i - 1]);
+-
+ 	crypto_hash_update(hash, sg, nbytes);
+ 	crypto_hash_final(hash, crc);
+ }
+Index: kernel/event.c
+===================================================================
+--- kernel/event.c	(working copy)
++++ kernel/event.c	(revision 145)
+@@ -28,7 +28,7 @@ static int event_recv_msg(struct sk_buff
+ 	return 0;
+ }
+ 
+-static void event_recv_skb(struct sk_buff *skb)
++static int event_recv_skb(struct sk_buff *skb)
+ {
+ 	int err;
+ 	struct nlmsghdr	*nlh;
+@@ -37,7 +37,7 @@ static void event_recv_skb(struct sk_buf
+ 	while (skb->len >= NLMSG_SPACE(0)) {
+ 		nlh = (struct nlmsghdr *)skb->data;
+ 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+-			break;
++			return 0;
+ 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+ 		if (rlen > skb->len)
+ 			rlen = skb->len;
+@@ -47,6 +47,19 @@ static void event_recv_skb(struct sk_buf
+ 			netlink_ack(skb, nlh, 0);
+ 		skb_pull(skb, rlen);
+ 	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
+ }
+ 
+ static int notify(void *data, int len, int gfp_mask)
+@@ -82,8 +95,8 @@ int event_send(u32 tid, u64 sid, u32 cid
+ 
+ int event_init(void)
+ {
+-	nl = netlink_kernel_create(&init_net, NETLINK_IET, 1, event_recv_skb,
+-				   NULL, THIS_MODULE);
++	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, NULL,
++				   THIS_MODULE);
+ 	if (!nl)
+ 		return -ENOMEM;
+ 	else
+Index: kernel/block-io.c
+===================================================================
+--- kernel/block-io.c	(working copy)
++++ kernel/block-io.c	(revision 145)
+@@ -28,10 +28,15 @@ struct tio_work {
+ 	struct completion tio_complete;
+ };
+ 
+-static void blockio_bio_endio(struct bio *bio, int error)
++static int
++blockio_bio_endio(struct bio *bio, unsigned int bytes_done, int error)
+ {
+ 	struct tio_work *tio_work = bio->bi_private;
+ 
++	/* Ignore partials */
++	if (bio->bi_size)
++		return 1;
++
+ 	error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? error : -EIO;
+ 
+ 	if (error)
+@@ -42,6 +47,8 @@ static void blockio_bio_endio(struct bio
+ 		complete(&tio_work->tio_complete);
+ 
+ 	bio_put(bio);
++
++	return 0;
+ }
+ 
+ /*
+Index: kernel/config.c
+===================================================================
+--- kernel/config.c	(working copy)
++++ kernel/config.c	(revision 145)
+@@ -40,7 +40,7 @@ int iet_procfs_init(void)
+ 	int i;
+ 	struct proc_dir_entry *ent;
+ 
+-	if (!(proc_iet_dir = proc_mkdir("iet", init_net.proc_net)))
++	if (!(proc_iet_dir = proc_mkdir("net/iet", 0)))
+ 		goto err;
+ 
+ 	proc_iet_dir->owner = THIS_MODULE;
+Index: kernel/digest.c
+===================================================================
+--- kernel/digest.c	(working copy)
++++ kernel/digest.c	(revision 145)
+@@ -161,17 +161,22 @@ static inline void __dbg_simulate_data_d
+ 	}
+ }
+ 
++/* Copied from linux-iscsi initiator and slightly adjusted */
++#define SETSG(sg, p, l) do {					\
++	(sg).page = virt_to_page((p));				\
++	(sg).offset = ((unsigned long)(p) & ~PAGE_CACHE_MASK);	\
++	(sg).length = (l);					\
++} while (0)
++
+ static void digest_header(struct hash_desc *hash, struct iscsi_pdu *pdu,
+ 			  u8 *crc)
+ {
+ 	struct scatterlist sg[2];
+ 	unsigned int nbytes = sizeof(struct iscsi_hdr);
+ 
+-	sg_init_table(sg, pdu->ahssize ? 2 : 1);
+-
+-	sg_set_buf(&sg[0], &pdu->bhs, nbytes);
++	SETSG(sg[0], &pdu->bhs, nbytes);
+ 	if (pdu->ahssize) {
+-		sg_set_buf(&sg[1], pdu->ahs, pdu->ahssize);
++		SETSG(sg[1], pdu->ahs, pdu->ahssize);
+ 		nbytes += pdu->ahssize;
+ 	}
+ 
+@@ -215,7 +220,6 @@ static void digest_data(struct hash_desc
+ 
+ 	assert(count <= ISCSI_CONN_IOV_MAX);
+ 
+-	sg_init_table(sg, ARRAY_SIZE(cmnd->conn->hash_sg));
+ 	crypto_hash_init(hash);
+ 
+ 	for (i = 0; size; i++) {
+@@ -224,13 +228,13 @@ static void digest_data(struct hash_desc
+ 		else
+ 			length = size;
+ 
+-		sg_set_page(&sg[i], tio->pvec[idx + i], length, offset);
++		sg[i].page = tio->pvec[idx + i];
++		sg[i].offset = offset;
++		sg[i].length = length;
+ 		size -= length;
+ 		offset = 0;
+ 	}
+ 
+-	sg_mark_end(&sg[i - 1]);
+-
+ 	crypto_hash_update(hash, sg, nbytes);
+ 	crypto_hash_final(hash, crc);
+ }
+Index: kernel/event.c
+===================================================================
+--- kernel/event.c	(working copy)
++++ kernel/event.c	(revision 145)
+@@ -28,7 +28,7 @@ static int event_recv_msg(struct sk_buff
+ 	return 0;
+ }
+ 
+-static void event_recv_skb(struct sk_buff *skb)
++static int event_recv_skb(struct sk_buff *skb)
+ {
+ 	int err;
+ 	struct nlmsghdr	*nlh;
+@@ -37,7 +37,7 @@ static void event_recv_skb(struct sk_buf
+ 	while (skb->len >= NLMSG_SPACE(0)) {
+ 		nlh = (struct nlmsghdr *)skb->data;
+ 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+-			break;
++			return 0;
+ 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+ 		if (rlen > skb->len)
+ 			rlen = skb->len;
+@@ -47,6 +47,19 @@ static void event_recv_skb(struct sk_buf
+ 			netlink_ack(skb, nlh, 0);
+ 		skb_pull(skb, rlen);
+ 	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
+ }
+ 
+ static int notify(void *data, int len, int gfp_mask)
+@@ -82,8 +95,8 @@ int event_send(u32 tid, u64 sid, u32 cid
+ 
+ int event_init(void)
+ {
+-	nl = netlink_kernel_create(&init_net, NETLINK_IET, 1, event_recv_skb,
+-				   NULL, THIS_MODULE);
++	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, NULL,
++				   THIS_MODULE);
+ 	if (!nl)
+ 		return -ENOMEM;
+ 	else
+Index: kernel/block-io.c
+===================================================================
+--- kernel/block-io.c	(working copy)
++++ kernel/block-io.c	(revision 142)
+@@ -28,10 +28,15 @@ struct tio_work {
+ 	struct completion tio_complete;
+ };
+ 
+-static void blockio_bio_endio(struct bio *bio, int error)
++static int
++blockio_bio_endio(struct bio *bio, unsigned int bytes_done, int error)
+ {
+ 	struct tio_work *tio_work = bio->bi_private;
+ 
++	/* Ignore partials */
++	if (bio->bi_size)
++		return 1;
++
+ 	error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? error : -EIO;
+ 
+ 	if (error)
+@@ -42,6 +47,8 @@ static void blockio_bio_endio(struct bio
+ 		complete(&tio_work->tio_complete);
+ 
+ 	bio_put(bio);
++
++	return 0;
+ }
+ 
+ /*
+Index: kernel/config.c
+===================================================================
+--- kernel/config.c	(working copy)
++++ kernel/config.c	(revision 142)
+@@ -40,7 +40,7 @@ int iet_procfs_init(void)
+ 	int i;
+ 	struct proc_dir_entry *ent;
+ 
+-	if (!(proc_iet_dir = proc_mkdir("iet", init_net.proc_net)))
++	if (!(proc_iet_dir = proc_mkdir("net/iet", 0)))
+ 		goto err;
+ 
+ 	proc_iet_dir->owner = THIS_MODULE;
+Index: kernel/digest.c
+===================================================================
+--- kernel/digest.c	(working copy)
++++ kernel/digest.c	(revision 142)
+@@ -161,15 +161,22 @@ static inline void __dbg_simulate_data_d
+ 	}
+ }
+ 
++/* Copied from linux-iscsi initiator and slightly adjusted */
++#define SETSG(sg, p, l) do {					\
++	(sg).page = virt_to_page((p));				\
++	(sg).offset = ((unsigned long)(p) & ~PAGE_CACHE_MASK);	\
++	(sg).length = (l);					\
++} while (0)
++
+ static void digest_header(struct hash_desc *hash, struct iscsi_pdu *pdu,
+ 			  u8 *crc)
+ {
+ 	struct scatterlist sg[2];
+ 	unsigned int nbytes = sizeof(struct iscsi_hdr);
+ 
+-	sg_set_buf(&sg[0], &pdu->bhs, nbytes);
++	SETSG(sg[0], &pdu->bhs, nbytes);
+ 	if (pdu->ahssize) {
+-		sg_set_buf(&sg[1], pdu->ahs, pdu->ahssize);
++		SETSG(sg[1], pdu->ahs, pdu->ahssize);
+ 		nbytes += pdu->ahssize;
+ 	}
+ 
+@@ -221,7 +228,9 @@ static void digest_data(struct hash_desc
+ 		else
+ 			length = size;
+ 
+-		sg_set_page(&sg[i], tio->pvec[idx + i], length, offset);
++		sg[i].page = tio->pvec[idx + i];
++		sg[i].offset = offset;
++		sg[i].length = length;
+ 		size -= length;
+ 		offset = 0;
+ 	}
+Index: kernel/event.c
+===================================================================
+--- kernel/event.c	(working copy)
++++ kernel/event.c	(revision 142)
+@@ -28,7 +28,7 @@ static int event_recv_msg(struct sk_buff
+ 	return 0;
+ }
+ 
+-static void event_recv_skb(struct sk_buff *skb)
++static int event_recv_skb(struct sk_buff *skb)
+ {
+ 	int err;
+ 	struct nlmsghdr	*nlh;
+@@ -37,7 +37,7 @@ static void event_recv_skb(struct sk_buf
+ 	while (skb->len >= NLMSG_SPACE(0)) {
+ 		nlh = (struct nlmsghdr *)skb->data;
+ 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+-			break;
++			return 0;
+ 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+ 		if (rlen > skb->len)
+ 			rlen = skb->len;
+@@ -47,6 +47,19 @@ static void event_recv_skb(struct sk_buf
+ 			netlink_ack(skb, nlh, 0);
+ 		skb_pull(skb, rlen);
+ 	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
+ }
+ 
+ static int notify(void *data, int len, int gfp_mask)
+@@ -82,8 +95,8 @@ int event_send(u32 tid, u64 sid, u32 cid
+ 
+ int event_init(void)
+ {
+-	nl = netlink_kernel_create(&init_net, NETLINK_IET, 1, event_recv_skb,
+-				   NULL, THIS_MODULE);
++	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, NULL,
++				   THIS_MODULE);
+ 	if (!nl)
+ 		return -ENOMEM;
+ 	else
Index: usr/isns.c
===================================================================
--- usr/isns.c	(.../tags/0.4.15)	(revision 147)
+++ usr/isns.c	(.../trunk)	(revision 147)
@@ -256,7 +256,8 @@
 
 	scn_flags = ISNS_SCN_FLAG_INITIATOR | ISNS_SCN_FLAG_OBJECT_REMOVE |
 		ISNS_SCN_FLAG_OBJECT_ADDED | ISNS_SCN_FLAG_OBJECT_UPDATED;
-	scn_flags = htonl(set_scn_flag(scn_flags));
+	set_scn_flag(scn_flags);
+	scn_flags = htonl(scn_flags);
 
 	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_SCN_BITMAP,
 			       sizeof(scn_flags), &scn_flags);
Index: usr/iscsid.c
===================================================================
--- usr/iscsid.c	(.../tags/0.4.15)	(revision 147)
+++ usr/iscsid.c	(.../trunk)	(revision 147)
@@ -89,11 +89,16 @@
 	char *buffer;
 
 	if (!conn->rsp.datasize) {
-		if (!conn->rsp_buffer)
+		if (!conn->rsp_buffer) {
 			conn->rsp_buffer = malloc(INCOMING_BUFSIZE);
+			if (!conn->rsp_buffer) {
+				log_error("Failed to alloc send buffer");
+				return;
+			}
+		}
 		conn->rsp.data = conn->rsp_buffer;
 	}
-	if (conn->rwsize + len > INCOMING_BUFSIZE) {
+	if (conn->rsp.datasize + len > INCOMING_BUFSIZE) {
 		log_warning("Dropping key (%s=%s)", key, value);
 		return;
 	}
@@ -385,7 +390,12 @@
 /* 			return; */
 /* 		} */
 
-		ki->param_get(conn->tid, 0, key_session, conn->session_param);
+		if (ki->param_get(conn->tid, 0, key_session,
+				  conn->session_param)) {
+			rsp->status_class = ISCSI_STATUS_TARGET_ERROR;
+			rsp->status_detail = ISCSI_STATUS_SVC_UNAVAILABLE;
+			conn->state = STATE_EXIT;
+		}
 	}
 	conn->exp_cmd_sn = be32_to_cpu(req->cmd_sn);
 	log_debug(1, "exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmd_sn);
Index: usr/ietd.c
===================================================================
--- usr/ietd.c	(.../tags/0.4.15)	(revision 147)
+++ usr/ietd.c	(.../trunk)	(revision 147)
@@ -307,9 +307,24 @@
 							      (conn->req.bhs.datalength[1] << 8) +
 							      conn->req.bhs.datalength[2]);
 					conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
+					if (conn->rwsize > INCOMING_BUFSIZE) {
+						log_warning("Recv PDU with "
+							    "invalid size %d "
+							    "(max: %d)",
+							    conn->rwsize,
+							    INCOMING_BUFSIZE);
+						conn->state = STATE_CLOSE;
+						goto conn_close;
+					}
 					if (conn->rwsize) {
-						if (!conn->req_buffer)
+						if (!conn->req_buffer) {
 							conn->req_buffer = malloc(INCOMING_BUFSIZE);
+							if (!conn->req_buffer) {
+								log_error("Failed to alloc recv buffer");
+								conn->state = STATE_CLOSE;
+								goto conn_close;
+							}
+						}
 						conn->buffer = conn->req_buffer;
 						conn->req.ahs = conn->buffer;
 						conn->req.data = conn->buffer + conn->req.ahssize;
@@ -396,6 +411,7 @@
 				exit(1);
 			}
 
+		conn_close:
 			if (conn->state == STATE_CLOSE) {
 				log_debug(0, "connection closed");
 				conn_free_pdu(conn);
Index: etc/initd/initd.gentoo
===================================================================
--- etc/initd/initd.gentoo	(.../tags/0.4.15)	(revision 147)
+++ etc/initd/initd.gentoo	(.../trunk)	(revision 147)
@@ -4,47 +4,14 @@
 #
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MEM_SIZE=1048576
 
 depend()
 {
         use net
 }
 
-configure_memsize()
-{
-    if [ -e /proc/sys/net/core/wmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/wmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_default
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_default
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_mem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_mem
-    fi
-
-    if [ -e  /proc/sys/net/ipv4/tcp_rmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_rmem
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_wmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_wmem
-    fi
-}
-
 start_server()
 {
-        configure_memsize
         modprobe -q crc32c
         modprobe iscsi_trgt
         /usr/sbin/ietd
Index: etc/initd/initd
===================================================================
--- etc/initd/initd	(.../tags/0.4.15)	(revision 147)
+++ etc/initd/initd	(.../trunk)	(revision 147)
@@ -4,47 +4,14 @@
 #
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MEM_SIZE=1048576
 
-configure_memsize()
-{
-    if [ -e /proc/sys/net/core/wmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/wmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_default
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_default
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_mem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_mem
-    fi
-
-    if [ -e  /proc/sys/net/ipv4/tcp_rmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_rmem
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_wmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_wmem
-    fi
-}
-
 start_server()
 {
-	configure_memsize
 	modprobe -q crc32c
 	modprobe iscsi_trgt
 	/usr/sbin/ietd
 }
-	
+
 stop_server()
 {
 	ietadm --op delete
Index: etc/initd/initd.debian
===================================================================
--- etc/initd/initd.debian	(.../tags/0.4.15)	(revision 147)
+++ etc/initd/initd.debian	(.../trunk)	(revision 147)
@@ -10,65 +10,29 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
-# Don't touch this "memsize thingy" unless you are blessed
-# with knowledge about it.
-MEM_SIZE=1048576
-
-configure_memsize()
-{
-    if [ -e /proc/sys/net/core/wmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/wmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_default
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_default
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_mem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_mem
-    fi
-
-    if [ -e  /proc/sys/net/ipv4/tcp_rmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_rmem
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_wmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_wmem
-    fi
-}
-
 RETVAL=0
 
 ietd_start()
 {
 	echo -n "Starting iSCSI enterprise target service: "
-	configure_memsize
 	modprobe -q crc32c
 	modprobe iscsi_trgt
 	start-stop-daemon --start --exec $DAEMON --quiet
 	RETVAL=$?
-	if [ $RETVAL == "0" ]; then
+	if [ $RETVAL -eq 0 ]; then
 	    echo "succeeded."
 	else
 	    echo "failed."
-	fi	    
+	fi
 }
-	
+
 ietd_stop()
 {
 	echo -n "Removing iSCSI enterprise target devices: "
-	# ugly, but ietadm does not allways provides correct exit values
+	# ugly, but ietadm does not always provide correct exit values
 	RETURN=`ietadm --op delete 2>&1`
 	RETVAL=$?
-	if [ $RETVAL == "0" ] && [[ $RETURN != "something wrong" ]]; then
+	if [ $RETVAL -eq 0 ] && [ x$RETURN != x"something wrong" ]; then
 	    echo "succeeded."
 	else
 	    echo "failed with reason :$RETURN"
@@ -78,19 +42,19 @@
 	echo -n "Stopping iSCSI enterprise target service: "
 	start-stop-daemon --stop --quiet --exec $DAEMON --pidfile $PID_FILE
 	RETVAL=$?
-	if [ $RETVAL == "0" ]; then
+	if [ $RETVAL -eq 0 ]; then
 	    echo "succeeded."
 	else
 	    echo "failed."
 	fi
-	# ugly, but pid file is not removed ba ietd
+	# ugly, but pid file is not removed by ietd
 	rm -f $PID_FILE
 
 	echo -n "Removing iSCSI enterprise target modules: "
 	modprobe -r iscsi_trgt
 	RETVAL=$?
 	modprobe -r crc32c 2>/dev/null
-	if [ $RETVAL == "0" ]; then
+	if [ $RETVAL -eq 0 ]; then
 	    echo "succeeded."
 	else
 	    echo "failed."
@@ -117,18 +81,18 @@
 	else
 		echo "no iSCSI enterprise target found!"
 		exit 1
-	fi	
+	fi
         ;;
   dump)
 	DUMP=`tempfile -p ietd`
 	RETVAL=$?
-	if [ $RETVAL != "0" ]; then
+	if [ $RETVAL -ne 0 ]; then
 	    echo "Failed to create dump file $DUMP"
 	    exit 1
 	fi
         ietadm --mode dump --all >$DUMP
 	RETVAL=$?
-	if [ $RETVAL != "0" ]; then
+	if [ $RETVAL -ne 0 ]; then
 	    echo "Error dumping config from daemon"
 	    rm $DUMP
 	    exit 1
Index: etc/initd/initd.redhat
===================================================================
--- etc/initd/initd.redhat	(.../tags/0.4.15)	(revision 147)
+++ etc/initd/initd.redhat	(.../trunk)	(revision 147)
@@ -16,45 +16,12 @@
 fi
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MEM_SIZE=1048576
 
-configure_memsize()
-{
-    if [ -e /proc/sys/net/core/wmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_max ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_max
-    fi
-
-    if [ -e /proc/sys/net/core/wmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/wmem_default
-    fi
-
-    if [ -e /proc/sys/net/core/rmem_default ]; then
-        echo ${MEM_SIZE} > /proc/sys/net/core/rmem_default
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_mem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_mem
-    fi
-
-    if [ -e  /proc/sys/net/ipv4/tcp_rmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_rmem
-    fi
-
-    if [ -e /proc/sys/net/ipv4/tcp_wmem ]; then
-        echo "${MEM_SIZE} ${MEM_SIZE} ${MEM_SIZE}" > /proc/sys/net/ipv4/tcp_wmem
-    fi
-}
-
 RETVAL=0
 
 start()
 {
 	echo -n "Starting iSCSI target service: "
-	configure_memsize
 	modprobe -q crc32c
 	modprobe iscsi_trgt
 	daemon /usr/sbin/ietd
@@ -62,7 +29,7 @@
 	echo
 	return $RETVAL
 }
-	
+
 stop()
 {
 	echo -n "Stopping iSCSI target service: "
@@ -71,7 +38,7 @@
 	modprobe -r iscsi_trgt 2>/dev/null
 	RETVAL=$?
 	modprobe -r crc32c 2>/dev/null
-	if [ $RETVAL == "0" ]; then
+	if [ $RETVAL -eq 0 ]; then
 		echo_success
 	else
 		echo_failure
@@ -102,7 +69,7 @@
 		exit 1
 	else
 		echo "ietd (pid $PID) is running..."
-	fi	
+	fi
 }
 
 case "$1" in
Index: Makefile
===================================================================
--- Makefile	(.../tags/0.4.15)	(revision 147)
+++ Makefile	(.../trunk)	(revision 147)
@@ -51,6 +51,16 @@
 # base first the earlier patch sets will not need to be modified.
 #
 
+# Compatibility patch for kernels >= 2.6.22 and <= 2.6.23
+ifeq ($(call kver_le,2,6,23),1)
+	PATCHES := $(PATCHES) compat-2.6.22-2.6.23.patch
+endif
+
+# Compatibility patch for kernels >= 2.6.19 and <= 2.6.21
+ifeq ($(call kver_le,2,6,21),1)
+	PATCHES := $(PATCHES) compat-2.6.19-2.6.21.patch
+endif
+
 # Compatibility patch for kernels >= 2.6.14 and <= 2.6.18
 ifeq ($(call kver_le,2,6,18),1)
 	PATCHES := $(PATCHES) compat-2.6.14-2.6.18.patch
@@ -140,27 +150,34 @@
 		rm -f .patched.*; \
 	fi
 
-install: install-kernel install-usr install-etc install-doc
+depmod:
+	@echo "Running depmod"
+	@if [ x$(DISTDIR) != x -o x$(INSTALL_MOD_PATH) != x ]; then \
+		depmod -aq -b $(DISTDIR)$(INSTALL_MOD_PATH) $(KVER); \
+	else \
+		depmod -aq $(KVER); \
+	fi
 
+install: install-usr install-etc install-doc install-kernel depmod
+
 install-kernel: kernel/iscsi_trgt.ko
 	@install -vD kernel/iscsi_trgt.ko \
 		$(DISTDIR)$(INSTALL_MOD_PATH)$(KMOD)/iscsi/iscsi_trgt.ko
-	-depmod -aq
 
 install-usr: usr/ietd usr/ietadm
 	@install -vD usr/ietd $(DISTDIR)/usr/sbin/ietd
 	@install -vD usr/ietadm $(DISTDIR)/usr/sbin/ietadm
 
 install-etc: install-initd
-	@if [ ! -e /etc/ietd.conf ]; then \
+	@if [ ! -e $(DISTDIR)/etc/ietd.conf ]; then \
 		install -vD -m 644 etc/ietd.conf \
 			$(DISTDIR)/etc/ietd.conf; \
 	fi
-	@if [ ! -e /etc/initiators.allow ]; then \
+	@if [ ! -e $(DISTDIR)/etc/initiators.allow ]; then \
 		install -vD -m 644 etc/initiators.allow \
 			$(DISTDIR)/etc/initiators.allow; \
 	fi
-	@if [ ! -e /etc/initiators.deny ]; then \
+	@if [ ! -e $(DISTDIR)/etc/initiators.deny ]; then \
 		install -vD -m 644 etc/initiators.deny \
 			$(DISTDIR)/etc/initiators.deny; \
 	fi
@@ -204,11 +221,10 @@
 			$(DISTDIR)$(MANDIR)/man$$s/$$f ; \
 	done
 
-uninstall: uninstall-kernel uninstall-usr uninstall-etc uninstall-doc
+uninstall: uninstall-kernel depmod uninstall-usr uninstall-etc uninstall-doc
 
 uninstall-kernel:
 	rm -f $(DISTDIR)$(INSTALL_MOD_PATH)$(KMOD)/iscsi/iscsi_trgt.ko
-	-depmod -aq
 
 uninstall-usr:
 	@rm -f $(DISTDIR)/usr/sbin/ietd
